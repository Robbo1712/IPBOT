import os
import time
import configparser
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import json
from sklearn.linear_model import LinearRegression
import ccxt
import telegram
import logging
from logging.handlers import RotatingFileHandler
import tradingpatterns # Added for your custom patterns

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        RotatingFileHandler("trading_bot_enhanced.log", maxBytes=10485760, backupCount=5, encoding='utf-8'), # Changed log file name
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("trading_bot_enhanced") # Changed logger name

class KuCoinSwingBotEnhanced: # Changed class name
    def __init__(self, config_file="config.txt"):
        """Initialize the trading bot with configuration."""
        self.config = self._load_config(config_file) [cite: 173]
        self.exchange = self._setup_exchange() [cite: 173]
        self.telegram_bot = self._setup_telegram() [cite: 173]
        self.symbols = self._get_top_usdt_symbols(top_n=30) [cite: 173, 174]
        self.timeframes = ['1h', '4h', '1d'] [cite: 174]
        self.default_ohlcv_timeframe = '1h' [cite: 174]
        self.short_window = 9 [cite: 174]
        self.long_window = 21 [cite: 174]
        self.rsi_period = 14 [cite: 174]
        self.rsi_overbought = 70 [cite: 174]
        self.rsi_oversold = 30 [cite: 174]
        self.bollinger_period = 20 [cite: 174]
        self.bollinger_std = 2 [cite: 175]
        self.volume_change_threshold = 20 [cite: 175]
        
        self.trade_history = {symbol: [] for symbol in self.symbols} [cite: 175]
        self.signals_generated = {symbol: 0 for symbol in self.symbols} [cite: 175]
        self.successful_signals = {symbol: 0 for symbol in self.symbols} [cite: 175]
        self.active_trades = {symbol: [] for symbol in self.symbols} [cite: 175, 176]
        self.last_signal_time = {symbol: None for symbol in self.symbols} [cite: 176]
        self.last_signal_direction = {symbol: 0 for symbol in self.symbols} [cite: 176]
        
        self.default_stop_loss_pct = 2.0 [cite: 176]
        self.default_take_profit_pct = 5.0 [cite: 176]
        self.min_stop_loss_pct = 0.5 [cite: 177]
        self.min_take_profit_pct = 1.0 [cite: 177]

        self.price_history_files = {symbol: f"price_history_{symbol.replace('/', '_')}.json" for symbol in self.symbols} [cite: 177]
        self.price_history = {symbol: None for symbol in self.symbols} [cite: 177]
        
        for symbol in self.symbols:
            self.load_price_history(symbol) [cite: 177]
        
        logger.info(f"Bot initialized to monitor multiple symbols: {', '.join(self.symbols)} on {self.timeframes} timeframes using {self.default_ohlcv_timeframe} as primary for context.") [cite: 178]
        self.send_telegram_info(f"🚀 Trading Bot Started\nMonitoring multiple symbols: {', '.join(self.symbols)} on {self.timeframes} timeframes using {self.default_ohlcv_timeframe} as primary for context.") [cite: 178]

    def _load_config(self, config_file):
        config = configparser.ConfigParser(inline_comment_prefixes='#')
        if not os.path.exists(config_file):
            logger.error(f"Config file not found: {config_file}")
            raise FileNotFoundError(f"Config file not found: {config_file}")
        config.read(config_file)
        
        try:
            # Updated to read from specific sections and keys
            return {
                'kucoin_api_key': config.get('KUCOIN', 'API_KEY'),
                'kucoin_api_secret': config.get('KUCOIN', 'API_SECRET'),
                'kucoin_api_passphrase': config.get('KUCOIN', 'API_PASSPHRASE'),
                'telegram_token': config.get('TELEGRAM', 'BOT_TOKEN'),
                'telegram_chat_id': config.get('TELEGRAM', 'CHAT_ID')
            }
        except configparser.NoSectionError as e:
            logger.error(f"Missing section in {config_file}: {e}. Please ensure sections like [KUCOIN] and [TELEGRAM] exist.")
            raise ValueError(f"Missing required section in {config_file}: {e}")
        except configparser.NoOptionError as e:
            logger.error(f"Missing configuration parameter in {config_file}: {e}") [cite: 188]
            raise ValueError(f"Missing required configuration in {config_file}: {e}") [cite: 188]

    def _setup_exchange(self):
        try:
            exchange = ccxt.kucoin({
                'apiKey': self.config['kucoin_api_key'],
                'secret': self.config['kucoin_api_secret'], [cite: 189]
                'password': self.config['kucoin_api_passphrase'], [cite: 189]
                'enableRateLimit': True
            })
            logger.info("KuCoin exchange connection established") [cite: 189]
            return exchange
        except Exception as e:
            logger.error(f"Failed to set up KuCoin exchange: {str(e)}") [cite: 190]
            raise

    def _setup_telegram(self):
        try:
            bot = telegram.Bot(token=self.config['telegram_token'])
            logger.info("Telegram bot initialized") [cite: 190]
            return bot
        except Exception as e:
            logger.error(f"Failed to set up Telegram bot: {str(e)}") [cite: 191]
            raise
          
    def send_telegram_info(self, message):
        """Send informational messages via Telegram."""
        try:
            self.telegram_bot.send_message(
                chat_id=self.config['telegram_chat_id'],
                text=message, [cite: 192]
                parse_mode=telegram.ParseMode.MARKDOWN # Assume markdown for info too 
            )
            logger.info(f"Telegram info message sent: {message[:50]}...") [cite: 192]
        except Exception as e:
            logger.error(f"Failed to send Telegram info message: {str(e)}") [cite: 192]   
                
    def send_signal_message(self, message):
        """Send a signal message via Telegram and return the message object."""
        try:
            sent_message = self.telegram_bot.send_message(
                chat_id=self.config['telegram_chat_id'],
                text=message, [cite: 179]
                parse_mode=telegram.ParseMode.MARKDOWN [cite: 179]
            )
            logger.info(f"Signal message sent: {message[:50]}...") [cite: 179]
            return sent_message
        except Exception as e:
            logger.error(f"Failed to send signal message: {str(e)}") [cite: 179]
            return None [cite: 180]
    
    def get_telegram_message_link(self, chat_id, message_id):
        """Returns a t.me link to the message."""
        if str(chat_id).startswith('-100'): [cite: 180]
            return f"https://t.me/c/{str(chat_id)[4:]}/{message_id}" [cite: 180]
        else:
            return f"https://t.me/c/{str(chat_id)}/{message_id}" # May not work for all private group types 
    
    def _get_top_usdt_symbols(self, top_n=30):
        try:
            tickers = self.exchange.fetch_tickers() [cite: 181]
            usdt_tickers = [
                (symbol, tick['quoteVolume'])
                for symbol, tick in tickers.items()
                if symbol.endswith('/USDT') [cite: 181]
                and not (symbol.startswith('BTC/') and symbol != 'BTC/USDT') # Keep BTC/USDT, exclude other BTC pairs like BTC/DAI 
                and tick.get('quoteVolume', 0) is not None [cite: 182]
            ]
            usdt_tickers.sort(key=lambda x: x[1], reverse=True) [cite: 182]
            top_symbols = [symbol for symbol, vol in usdt_tickers[:top_n]] [cite: 182]
            if not top_symbols: # Fallback if filtering is too aggressive 
                logger.warning("No top USDT symbols found with current criteria, falling back.") [cite: 183]
                return self._get_all_usdt_symbols(limit=top_n) [cite: 183]
            return top_symbols [cite: 183]
        except Exception as e:
            logger.error(f"Failed to fetch top USDT symbols: {str(e)}") [cite: 183]
            return self._get_all_usdt_symbols(limit=top_n) [cite: 184]

    def _get_all_usdt_symbols(self, limit=30): # Added limit for fallback 
        try:
            markets = self.exchange.load_markets() [cite: 184]
            usdt_symbols = [
                symbol for symbol in markets
                if symbol.endswith('/USDT') [cite: 184]
                and not (symbol.startswith('BTC/') and symbol != 'BTC/USDT') [cite: 185]
                and markets[symbol].get('active', False) [cite: 185]
            ]
            return usdt_symbols[:limit] if usdt_symbols else ["BTC/USDT", "ETH/USDT"] # Ensure some symbols exist 
        except Exception as e:
            logger.error(f"Failed to fetch all USDT symbols: {str(e)}") [cite: 185]
            return ["BTC/USDT", "ETH/USDT"] # Hardcoded fallback 

    def load_price_history(self, symbol):
        try:
            filename = self.price_history_files[symbol] [cite: 193]
            if os.path.exists(filename): [cite: 193]
                with open(filename, 'r') as f: [cite: 193]
                    self.price_history[symbol] = json.load(f) [cite: 193]
                logger.info(f"Loaded price history for {symbol} with {len(self.price_history[symbol].get('swings', []))} swing records and {len(self.price_history[symbol].get('trade_results', []))} trade records.") [cite: 194]
            else:
                self.price_history[symbol] = {"swings": [], "trade_results": []} [cite: 194]
                logger.info(f"Initialized new price history record for {symbol}") [cite: 194]
        except Exception as e:
            logger.error(f"Error loading price history for {symbol}: {str(e)}") [cite: 194, 195]
            self.price_history[symbol] = {"swings": [], "trade_results": []} [cite: 195]

    def save_price_history(self, symbol):
        try:
            filename = self.price_history_files[symbol] [cite: 195]
            with open(filename, 'w') as f: [cite: 195]
                json.dump(self.price_history[symbol], f, indent=4) # Added indent for readability 
            logger.info(f"Price history saved for {symbol}") [cite: 195, 196]
        except Exception as e:
            logger.error(f"Error saving price history for {symbol}: {str(e)}") [cite: 196]

    def update_price_history(self, df, symbol):
        if df is None or df.empty: [cite: 196]
            logger.warning(f"DataFrame is empty for {symbol}, cannot update price history.") [cite: 196]
            return
        try:
            df_copy = df.copy() # Work on a copy 
            df_copy['is_local_high'] = False [cite: 197]
            df_copy['is_local_low'] = False [cite: 197]
            
            window_size = 3 [cite: 197]
            
            for i in range(window_size, len(df_copy) - window_size): [cite: 197]
                if df_copy['high'].iloc[i] == df_copy['high'].iloc[i-window_size:i+window_size+1].max(): [cite: 198]
                    df_copy.loc[df_copy.index[i], 'is_local_high'] = True [cite: 198]
                
                if df_copy['low'].iloc[i] == df_copy['low'].iloc[i-window_size:i+window_size+1].min(): [cite: 198]
                    df_copy.loc[df_copy.index[i], 'is_local_low'] = True [cite: 198]
            
            highs = df_copy[df_copy['is_local_high']] [cite: 199]
            lows = df_copy[df_copy['is_local_low']] [cite: 199]
            
            new_swings = [] [cite: 199]
            for idx, row in highs.iterrows(): [cite: 199]
                future_lows = lows[lows.index > idx] [cite: 199]
                if not future_lows.empty: [cite: 200]
                    next_low = future_lows.iloc[0] [cite: 200]
                    time_to_low = (next_low.name - idx).total_seconds() / 60 [cite: 200]
                    price_change_pct = (next_low['low'] - row['high']) / row['high'] * 100 [cite: 200]
                    if abs(price_change_pct) > 0.5: [cite: 201]
                        new_swings.append({
                            "start_time": idx.strftime("%Y-%m-%d %H:%M:%S"), "end_time": next_low.name.strftime("%Y-%m-%d %H:%M:%S"), [cite: 201]
                            "start_price": float(row['high']), "end_price": float(next_low['low']), "direction": "down", [cite: 201, 202]
                            "duration_minutes": time_to_low, "change_percent": float(price_change_pct) [cite: 202]
                        })
            
            for idx, row in lows.iterrows(): [cite: 202]
                future_highs = highs[highs.index > idx] [cite: 203]
                if not future_highs.empty: [cite: 203]
                    next_high = future_highs.iloc[0] [cite: 203]
                    time_to_high = (next_high.name - idx).total_seconds() / 60 [cite: 203]
                    price_change_pct = (next_high['high'] - row['low']) / row['low'] * 100 [cite: 203]
                    if abs(price_change_pct) > 0.5: [cite: 204]
                        new_swings.append({
                            "start_time": idx.strftime("%Y-%m-%d %H:%M:%S"), "end_time": next_high.name.strftime("%Y-%m-%d %H:%M:%S"), [cite: 204]
                            "start_price": float(row['low']), "end_price": float(next_high['high']), "direction": "up", [cite: 205]
                            "duration_minutes": time_to_high, "change_percent": float(price_change_pct) [cite: 205]
                        })
            
            if new_swings: [cite: 205]
                self.price_history[symbol]["swings"].extend(new_swings) [cite: 206]
                self.price_history[symbol]["swings"] = sorted(self.price_history[symbol]["swings"], key=lambda x: x['start_time']) [cite: 206]
                unique_swings = [] [cite: 207]
                seen_swings = set() [cite: 207]
                for swing in self.price_history[symbol]["swings"]: [cite: 207]
                    identifier = (swing['start_time'], swing['direction']) [cite: 207]
                    if identifier not in seen_swings: [cite: 207]
                        unique_swings.append(swing) [cite: 208]
                        seen_swings.add(identifier) [cite: 208]
                self.price_history[symbol]["swings"] = unique_swings [cite: 208]

            if len(self.price_history[symbol]["swings"]) > 1000: [cite: 208]
                self.price_history[symbol]["swings"] = self.price_history[symbol]["swings"][-1000:] [cite: 208]
            
            self.save_price_history(symbol) [cite: 209]
        except Exception as e:
            logger.error(f"Error updating price history for {symbol}: {str(e)}") [cite: 209]
          
    def fetch_ohlcv_data(self, symbol, timeframe='1h', limit=100):
        try:
            if not isinstance(symbol, str): [cite: 209, 210]
                logger.error(f"Invalid symbol type for fetch_ohlcv_data: {type(symbol)}. Expected str.") [cite: 210, 211]
                if hasattr(symbol, 'name') and isinstance(symbol.name, str): # Crude check 
                     symbol = symbol.name [cite: 211]
                else:
                     raise ValueError(f"Invalid symbol argument: {symbol}") [cite: 212]

            ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit) [cite: 212]
            if not ohlcv: # Check if ohlcv is empty 
                logger.warning(f"No OHLCV data returned for {symbol} on {timeframe}.") [cite: 212]
                return pd.DataFrame() # Return empty DataFrame 

            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume']) [cite: 213]
            for col in ['open', 'high', 'low', 'close', 'volume']: [cite: 213]
                df[col] = pd.to_numeric(df[col], errors='coerce') [cite: 213]
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms') [cite: 213]
            df.set_index('timestamp', inplace=True) [cite: 213]
            df.dropna(inplace=True) [cite: 213]
            logger.info(f"Fetched {len(df)} candlesticks for {symbol} on {timeframe}") [cite: 214]
            return df
        except ccxt.BadSymbol: [cite: 214]
            logger.error(f"BadSymbol: Could not fetch OHLCV data for symbol '{symbol}' on {timeframe}. It might be an invalid symbol or delisted.") [cite: 214, 215]
            return pd.DataFrame() [cite: 215]
        except Exception as e:
            logger.error(f"Error fetching OHLCV data for {symbol} on {timeframe}: {str(e)}") [cite: 215]
            return pd.DataFrame() # Return empty DataFrame on other errors 
        
    def fetch_all_timeframes(self, symbol):
        data = {} [cite: 215]
        for timeframe in self.timeframes: # Using self.timeframes ['1h', '4h', '1d'] 
            df = self.fetch_ohlcv_data(symbol, timeframe=timeframe, limit=200) # Increased limit for more robust indicator calculation 
            if not df.empty: [cite: 216]
                df = self.calculate_indicators(df) [cite: 216]
                if not df.empty: [cite: 216]
                    data[timeframe] = df [cite: 217]
        return data

    def calculate_indicators(self, df):
        if df.empty: [cite: 217]
            return pd.DataFrame() [cite: 217]
            
        data = df.copy() [cite: 217]
        data['ema_short'] = data['close'].ewm(span=self.short_window, adjust=False).mean() [cite: 218]
        data['ema_long'] = data['close'].ewm(span=self.long_window, adjust=False).mean() [cite: 218]
        
        delta = data['close'].diff() [cite: 218]
        gain = (delta.where(delta > 0, 0)).rolling(window=self.rsi_period).mean() [cite: 218]
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.rsi_period).mean() [cite: 218]
        rs = gain / loss [cite: 218]
        data['rsi'] = 100 - (100 / (1 + rs)) [cite: 219]
        
        data['sma'] = data['close'].rolling(window=self.bollinger_period).mean() [cite: 219]
        data['std'] = data['close'].rolling(window=self.bollinger_period).std() [cite: 219]
        data['upper_band'] = data['sma'] + (data['std'] * self.bollinger_std) [cite: 219]
        data['lower_band'] = data['sma'] - (data['std'] * self.bollinger_std) [cite: 219]
        
        data['ema_12'] = data['close'].ewm(span=12, adjust=False).mean() [cite: 219]
        data['ema_26'] = data['close'].ewm(span=26, adjust=False).mean() [cite: 219]
        data['macd'] = data['ema_12'] - data['ema_26'] [cite: 220]
        data['macd_signal'] = data['macd'].ewm(span=9, adjust=False).mean() [cite: 220]
        data['macd_hist'] = data['macd'] - data['macd_signal'] [cite: 220]
        
        data['volume_ma'] = data['volume'].rolling(window=20).mean() [cite: 220]
        data['volume_change'] = (data['volume'] / data['volume_ma'] - 1) * 100 [cite: 220]
        
        k_period = 14 [cite: 220]
        d_period = 3 [cite: 220]
        low_min = data['low'].rolling(window=k_period).min() [cite: 221]
        high_max = data['high'].rolling(window=k_period).max() [cite: 221]
        data['stoch_k'] = 100 * ((data['close'] - low_min) / (high_max - low_min)) [cite: 221]
        data['stoch_d'] = data['stoch_k'].rolling(window=d_period).mean() [cite: 221]
        
        # Corrected DM calculation
        df_temp = pd.DataFrame() [cite: 223]
        df_temp['high_diff'] = data['high'].diff() [cite: 223]
        df_temp['low_diff'] = data['low'].diff() [cite: 223]

        df_temp['plus_dm'] = 0.0 [cite: 223]
        df_temp.loc[(df_temp['high_diff'] > -df_temp['low_diff']) & (df_temp['high_diff'] > 0), 'plus_dm'] = df_temp['high_diff'] [cite: 223]
        
        df_temp['minus_dm'] = 0.0 [cite: 224]
        df_temp.loc[(-df_temp['low_diff'] > df_temp['high_diff']) & (-df_temp['low_diff'] > 0), 'minus_dm'] = -df_temp['low_diff'] [cite: 224]

        tr1 = data['high'] - data['low'] [cite: 224]
        tr2 = abs(data['high'] - data['close'].shift(1)) [cite: 224]
        tr3 = abs(data['low'] - data['close'].shift(1)) [cite: 224]
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1) [cite: 224]
        
        atr_period = 14 [cite: 224]
        atr = tr.ewm(alpha=1/atr_period, adjust=False).mean() # Smoothed ATR (Wilder's) - common for ADX 

        plus_di = 100 * (df_temp['plus_dm'].ewm(alpha=1/atr_period, adjust=False).mean() / atr) [cite: 225]
        minus_di = 100 * (df_temp['minus_dm'].ewm(alpha=1/atr_period, adjust=False).mean() / atr) [cite: 225]
        
        dx_denominator = (plus_di + minus_di) [cite: 225]
        dx = 100 * abs(plus_di - minus_di) / dx_denominator.where(dx_denominator != 0, np.nan) # Avoid division by zero 
        data['adx'] = dx.ewm(alpha=1/atr_period, adjust=False).mean() # Smoothed ADX 
        
        data['obv'] = (np.sign(data['close'].diff()) * data['volume']).fillna(0).cumsum() [cite: 226]
        data['atr'] = tr.rolling(window=14).mean() # Keep original ATR for TP/SL if preferred 

        return data.dropna() # Drop NaNs created by rolling windows at the start 
    
    def simplified_indicator_signal(self, df):
        if df is None or df.empty or len(df) < 2: # Need at least 2 rows for macd crossover 
            return 0
        latest = df.iloc[-1] [cite: 227]
        prev = df.iloc[-2] [cite: 227]
        signal = 0 [cite: 227]

        if 'rsi' in latest and latest['rsi'] < 25: signal += 1 [cite: 227]
        elif 'rsi' in latest and latest['rsi'] > 75: signal -= 1 [cite: 228]

        if 'macd' in latest and 'macd_signal' in latest and \
           'macd' in prev and 'macd_signal' in prev: [cite: 228]
            if (latest['macd'] > latest['macd_signal']) and (prev['macd'] < prev['macd_signal']): signal += 1 [cite: 228]
            elif (latest['macd'] < latest['macd_signal']) and (prev['macd'] > prev['macd_signal']): signal -= 1 [cite: 228]

        if 'close' in latest and 'lower_band' in latest and latest['close'] < latest['lower_band']: signal += 1 [cite: 229]
        elif 'close' in latest and 'upper_band' in latest and latest['close'] > latest['upper_band']: signal -= 1 [cite: 229]

        if 'volume' in latest and 'volume_ma' in latest and latest['volume_ma'] > 0: # Avoid division by zero 
             if latest['volume'] > latest['volume_ma'] * 1.25: signal *= 2 [cite: 229]
        
        if signal >= 2: return 1 [cite: 230]
        elif signal <= -2: return -1 [cite: 230]
        else: return 0 [cite: 230]

    def detect_price_patterns(self, df):
        # This is the simplified pattern detection from backup.txt.
        # You can integrate calls to your `tradingpatterns` module here if desired.
        # For example:
        # if tradingpatterns.detect_head_shoulder(df_copy): # Make sure df_copy is suitable
        #     signal = -1 # Or appropriate signal
        # etc.
        if df is None or df.empty or len(df) < 30: # Need enough data for patterns 
            return 0
        signal = 0 [cite: 230]
        close = df['close'] [cite: 231]

        recent_highs = close[-10:].nlargest(2) [cite: 231]
        if len(recent_highs) == 2 and recent_highs.iloc[0] / recent_highs.iloc[1] < 1.005: # Tops are close 
            if close.iloc[-1] < recent_highs.mean() * 0.995: # Price fell below average of tops 
                signal = -1 [cite: 231]

        recent_lows = close[-10:].nsmallest(2) [cite: 231]
        if len(recent_lows) == 2 and recent_lows.iloc[1] / recent_lows.iloc[0] < 1.005: # Lows are close 
            if close.iloc[-1] > recent_lows.mean() * 1.005: # Price rose above average of lows 
                signal = 1 [cite: 232]
        
        if len(close) > 30: [cite: 233]
            resistance = close[-31:-1].max() # Resistance from previous 30 candles 
            if close.iloc[-1] > resistance: [cite: 233]
                signal = 1 [cite: 233]
            
            support = close[-31:-1].min() # Support from previous 30 candles 
            if close.iloc[-1] < support: [cite: 234]
                signal = -1 [cite: 234]
        return signal

    def calculate_dynamic_tp_sl(self, df, entry_price, direction):
        if df is None or df.empty or 'atr' not in df.columns or df['atr'].isnull().all(): [cite: 234]
            logger.warning("ATR not available for dynamic TP/SL, using default percentages.") [cite: 234]
            sl_pct = self.default_stop_loss_pct / 100 [cite: 235]
            tp_pct = self.default_take_profit_pct / 100 [cite: 235]
            if direction == 1: # Long 
                SL = entry_price * (1 - sl_pct) [cite: 235]
                TP1 = entry_price * (1 + tp_pct) [cite: 235]
                TP2 = entry_price * (1 + tp_pct * 1.5) # Example scaling 
                TP3 = entry_price * (1 + tp_pct * 2.0) # Example scaling 
            else: # Short 
                SL = entry_price * (1 + sl_pct) [cite: 236]
                TP1 = entry_price * (1 - tp_pct) [cite: 236]
                TP2 = entry_price * (1 - tp_pct * 1.5) [cite: 237]
                TP3 = entry_price * (1 - tp_pct * 2.0) [cite: 237]
            return round(TP1, 4), round(TP2, 4), round(TP3, 4), round(SL, 4) [cite: 237]

        atr = df['atr'].iloc[-1] [cite: 237]
        if atr == 0: atr = entry_price * 0.01 # Safety for zero ATR 

        if direction == 1: # Long 
            TP1 = entry_price + (atr * 1.5) [cite: 238]
            TP2 = entry_price + (atr * 2.5) [cite: 238]
            TP3 = entry_price + (atr * 4.0) [cite: 238]
            SL = entry_price - (atr * 1.0) [cite: 238]
        else: # Short 
            TP1 = entry_price - (atr * 1.5) [cite: 239]
            TP2 = entry_price - (atr * 2.5) [cite: 239]
            TP3 = entry_price - (atr * 4.0) [cite: 239]
            SL = entry_price + (atr * 1.0) [cite: 239]
        return round(TP1, 4), round(TP2, 4), round(TP3, 4), round(SL, 4) [cite: 239]
    
    def generate_final_trade_signal(self, symbol: str):
        """ Generates a trade signal based on multi-timeframe analysis. Expects a symbol string.  """
        data_all_tf = self.fetch_all_timeframes(symbol) # data_all_tf is a dict of DFs {timeframe: df} 

        if not data_all_tf: [cite: 241]
            logger.warning(f"No data fetched by fetch_all_timeframes for {symbol}. Cannot generate signal.") [cite: 241]
            return None

        timeframe_signals = [] [cite: 241]
        for tf_name, df_tf in data_all_tf.items(): [cite: 241]
            if df_tf.empty: [cite: 241]
                logger.warning(f"Empty dataframe for {symbol} on timeframe {tf_name}, skipping this timeframe for signal.") [cite: 242]
                continue
            indicator_signal = self.simplified_indicator_signal(df_tf) [cite: 242]
            pattern_signal = self.detect_price_patterns(df_tf) # Uses the simplified patterns for now
            total_tf_signal = indicator_signal + pattern_signal [cite: 242]
            timeframe_signals.append(total_tf_signal) [cite: 242]

        if not timeframe_signals: # No valid timeframe data processed 
            logger.warning(f"No valid timeframe data to process for signals for {symbol}.") [cite: 243]
            return None
            
        signal_sum = sum(timeframe_signals) [cite: 243]
        direction = 0 [cite: 243]
        if signal_sum >= 2: direction = 1 [cite: 243]
        elif signal_sum <= -2: direction = -1 [cite: 244]
        else: return None # No strong consensus 

        primary_tf_df = data_all_tf.get(self.default_ohlcv_timeframe) [cite: 244]
        if primary_tf_df is None or primary_tf_df.empty: [cite: 244]
            logger.warning(f"Primary timeframe {self.default_ohlcv_timeframe} data not available for {symbol} to finalize signal.") [cite: 244]
            available_tfs = list(data_all_tf.keys()) [cite: 245]
            if not available_tfs: return None [cite: 245]
            primary_tf_df = data_all_tf[available_tfs[0]] [cite: 245]
            if primary_tf_df is None or primary_tf_df.empty: return None [cite: 245]
            logger.info(f"Using {available_tfs[0]} data for entry/TP/SL for {symbol} as primary was unavailable.") [cite: 245]

        entry_price = primary_tf_df['close'].iloc[-1] [cite: 246]
        TP1, TP2, TP3, SL = self.calculate_dynamic_tp_sl(primary_tf_df, entry_price, direction) [cite: 246]

        return {
            'symbol': symbol, [cite: 246]
            'direction': 'Long' if direction == 1 else 'Short', [cite: 246]
            'entry_price': entry_price, [cite: 246]
            'TP1': TP1, 'TP2': TP2, 'TP3': TP3, 'SL': SL [cite: 246]
        }

    def get_market_context(self, df, symbol):
        if df is None or df.empty or len(df) < 2: # Need at least 2 for diff() 
            return {
                "symbol": symbol, "price": np.nan, "price_change_24h": 0, "volatility": 0, [cite: 247]
                "rsi": np.nan, "trend": "N/A", "bollinger_position": "N/A" [cite: 247]
            }
        last_row = df.iloc[-1] [cite: 248]
        price = last_row['close'] [cite: 248]
        
        candles_for_24h = 24 [cite: 248]
        if len(df) >= candles_for_24h: [cite: 248]
            price_24h_ago = df.iloc[-candles_for_24h]['close'] [cite: 248]
            price_change_24h = ((price - price_24h_ago) / price_24h_ago) * 100 if price_24h_ago != 0 else 0 [cite: 248, 249]
        else:
            price_change_24h = 0 [cite: 249]
        
        atr = df['atr'].iloc[-1] if 'atr' in df.columns and not df['atr'].empty else 0 [cite: 249]
        volatility = (atr / price) * 100 if price != 0 else 0 [cite: 249]
        
        rsi = last_row['rsi'] if 'rsi' in last_row else np.nan [cite: 249, 250]
        
        trend = "N/A" [cite: 250]
        if 'ema_short' in last_row and 'ema_long' in last_row: [cite: 250]
            if last_row['ema_short'] > last_row['ema_long']: trend = "Bullish" [cite: 250]
            else: trend = "Bearish" [cite: 250]
        
        bb_position = "N/A" [cite: 250]
        if 'upper_band' in last_row and 'lower_band' in last_row: [cite: 250, 251]
            if price > last_row['upper_band']: bb_position = "Above upper band" [cite: 251]
            elif price < last_row['lower_band']: bb_position = "Below lower band" [cite: 251]
            else: bb_position = "Between bands" [cite: 251]
        
        return {
            "symbol": symbol, "price": price, "price_change_24h": price_change_24h, [cite: 251]
            "volatility": volatility, "rsi": rsi, "trend": trend, "bollinger_position": bb_position [cite: 252]
        }

    def backtest_strategy(self, symbol, days=7):
        default_timeframe_for_backtest = self.default_ohlcv_timeframe [cite: 252]
        candles_needed = int((days * 24 * 60) / self._timeframe_to_minutes(default_timeframe_for_backtest)) + 50 # Add buffer for indicator warmup 
        
        try:
            df_hist = self.fetch_ohlcv_data(symbol, timeframe=default_timeframe_for_backtest, limit=candles_needed) [cite: 252]
            if df_hist.empty or len(df_hist) < 60: # Need sufficient data 
                logger.warning(f"Not enough historical data for backtesting {symbol} ({len(df_hist)} candles).") [cite: 253]
                return {'symbol': symbol, 'period': f"{days} days", 'total_trades': 0, 'message': 'Not enough historical data'}, [] [cite: 253]

            df_with_indicators = self.calculate_indicators(df_hist) [cite: 253]
            if df_with_indicators.empty: [cite: 253]
                logger.warning(f"Not enough data after indicator calculation for backtesting {symbol}.") [cite: 254]
                return {'symbol': symbol, 'period': f"{days} days", 'total_trades': 0, 'message': 'Not enough data post-indicators'}, [] [cite: 254]

            self.update_price_history(df_with_indicators, symbol) # Learn from this data 
            
            signals_list = [] [cite: 254]
            min_rows_for_signal_logic = 30 # For detect_price_patterns primarily 
            for i in range(len(df_with_indicators)): [cite: 255]
                if i < min_rows_for_signal_logic -1 : # Ensure enough lookback for pattern detection 
                    signals_list.append(0) [cite: 255]
                    continue
                
                current_df_slice = df_with_indicators.iloc[:i+1] [cite: 256]
                indicator_signal_val = self.simplified_indicator_signal(current_df_slice) [cite: 256]
                pattern_signal_val = self.detect_price_patterns(current_df_slice) [cite: 256]
                total_signal = indicator_signal_val + pattern_signal_val [cite: 256]
                
                final_signal = 0 [cite: 257]
                if total_signal >= 2: final_signal = 1 [cite: 257]
                elif total_signal <= -2: final_signal = -1 [cite: 257]
                signals_list.append(final_signal) [cite: 257]

            df_with_indicators['signal'] = signals_list [cite: 257]
            df_backtest = df_with_indicators.copy() [cite: 258]

            initial_balance = 1000 [cite: 258]
            balance = initial_balance [cite: 258]
            position = 0  # 0 = no position, 1 = long, -1 = short 
            entry_price = 0 [cite: 258]
            entry_time = None [cite: 259]
            trades = [] [cite: 259]
            
            current_sl = 0 [cite: 259]
            current_tp = 0 [cite: 259]

            for i in range(1, len(df_backtest)): # Start from 1 to use previous row if needed 
                signal = df_backtest['signal'].iloc[i] [cite: 260]
                price = df_backtest['close'].iloc[i] [cite: 260]
                current_candle_time = df_backtest.index[i] [cite: 260]

                if position == 1: # Long position 
                    if price <= current_sl: # Stop Loss Hit 
                        position = 0 [cite: 261]
                        profit_pct = (current_sl - entry_price) / entry_price * 100 [cite: 261]
                        balance += balance * (profit_pct / 100) [cite: 262]
                        trades.append({'entry_time': entry_time, 'entry_price': entry_price, 'exit_time': current_candle_time, 'exit_price': current_sl, 'profit_pct': profit_pct, 'status': 'SL'}) [cite: 262]
                    elif price >= current_tp: # Take Profit Hit 
                        position = 0 [cite: 263]
                        profit_pct = (current_tp - entry_price) / entry_price * 100 [cite: 263]
                        balance += balance * (profit_pct / 100) [cite: 263]
                        trades.append({'entry_time': entry_time, 'entry_price': entry_price, 'exit_time': current_candle_time, 'exit_price': current_tp, 'profit_pct': profit_pct, 'status': 'TP'}) [cite: 263, 264]
                elif position == -1: # Short position 
                    if price >= current_sl: # Stop Loss Hit 
                        position = 0 [cite: 264]
                        profit_pct = (entry_price - current_sl) / entry_price * 100 [cite: 265]
                        balance += balance * (profit_pct / 100) [cite: 265]
                        trades.append({'entry_time': entry_time, 'entry_price': entry_price, 'exit_time': current_candle_time, 'exit_price': current_sl, 'profit_pct': profit_pct, 'status': 'SL'}) [cite: 265]
                    elif price <= current_tp: # Take Profit Hit 
                        position = 0 [cite: 266]
                        profit_pct = (entry_price - current_tp) / entry_price * 100 [cite: 266]
                        balance += balance * (profit_pct / 100) [cite: 266]
                        trades.append({'entry_time': entry_time, 'entry_price': entry_price, 'exit_time': current_candle_time, 'exit_price': current_tp, 'profit_pct': profit_pct, 'status': 'TP'}) [cite: 266, 267]

                if position == 0: [cite: 267]
                    if signal == 1:  # Buy signal 
                        position = 1 [cite: 268]
                        entry_price = price [cite: 268]
                        entry_time = current_candle_time [cite: 268]
                        tp1, _, _, sl = self.calculate_dynamic_tp_sl(df_backtest.iloc[:i+1], entry_price, 1) [cite: 269]
                        current_sl = sl [cite: 269]
                        current_tp = tp1 [cite: 269]
                    elif signal == -1: # Sell signal 
                        position = -1 [cite: 270]
                        entry_price = price [cite: 270]
                        entry_time = current_candle_time [cite: 270]
                        tp1, _, _, sl = self.calculate_dynamic_tp_sl(df_backtest.iloc[:i+1], entry_price, -1) [cite: 271]
                        current_sl = sl [cite: 271]
                        current_tp = tp1 [cite: 271]
            
            if position != 0: [cite: 272]
                exit_price = df_backtest['close'].iloc[-1] [cite: 272]
                if position == 1: profit_pct = (exit_price - entry_price) / entry_price * 100 [cite: 272]
                else: profit_pct = (entry_price - exit_price) / entry_price * 100 [cite: 272, 273]
                balance += balance * (profit_pct/100) [cite: 273]
                trades.append({'entry_time': entry_time, 'entry_price': entry_price, 'exit_time': df_backtest.index[-1], 'exit_price': exit_price, 'profit_pct': profit_pct, 'status': 'ClosedAtEnd'}) [cite: 273]

            for trade in trades: [cite: 273]
                trade_result_entry = {
                    'entry_time': trade['entry_time'].strftime("%Y-%m-%d %H:%M:%S"), [cite: 274]
                    'entry_price': float(trade['entry_price']), [cite: 274]
                    'exit_time': trade['exit_time'].strftime("%Y-%m-%d %H:%M:%S"), [cite: 274]
                    'exit_price': float(trade['exit_price']), [cite: 274]
                    'profit_pct': float(trade['profit_pct']), [cite: 275]
                    'profit_amount': (trade['profit_pct']/100) * initial_balance, # Simplified profit amount 
                    'duration_minutes': (trade['exit_time'] - trade['entry_time']).total_seconds() / 60, [cite: 275]
                    'stop_loss_used': float(current_sl if trade['status'] == 'SL' else np.nan), # Example values 
                    'take_profit_used': float(current_tp if trade['status'] == 'TP' else np.nan), # Example values 
                    'signal_type': 'buy' if trade['entry_price'] < trade['exit_price'] and trade['status'] != 'SL' else 'sell', # Approximation 
                    'exit_reason': trade['status'] [cite: 276]
                }
                self.price_history[symbol]['trade_results'].append(trade_result_entry) [cite: 277]

            if len(self.price_history[symbol]['trade_results']) > 200: [cite: 277]
                self.price_history[symbol]['trade_results'] = self.price_history[symbol]['trade_results'][-200:] [cite: 277]
            self.save_price_history(symbol) [cite: 277]
            
            total_trades = len(trades) [cite: 277]
            winning_trades = sum(1 for trade in trades if trade['profit_pct'] > 0) [cite: 277, 278]
            
            if total_trades > 0: [cite: 278]
                win_rate = (winning_trades / total_trades) * 100 [cite: 278]
                avg_profit = sum(trade['profit_pct'] for trade in trades) / total_trades [cite: 278]
                max_profit = max((trade['profit_pct'] for trade in trades), default=0) [cite: 278]
                max_loss = min((trade['profit_pct'] for trade in trades), default=0) [cite: 279]
                sl_hits = sum(1 for trade in trades if trade['status'] == 'SL') [cite: 279]
                tp_hits = sum(1 for trade in trades if trade['status'] == 'TP') [cite: 279]
                sl_rate = (sl_hits / total_trades) * 100 [cite: 279]
                tp_rate = (tp_hits / total_trades) * 100 [cite: 280]
                total_return = ((balance - initial_balance) / initial_balance) * 100 [cite: 280]
                
                report = {
                    'symbol': symbol, 'period': f"{days} days", 'total_trades': total_trades, [cite: 280]
                    'win_rate': win_rate, 'avg_profit': avg_profit, 'max_profit': max_profit, [cite: 281]
                    'max_loss': max_loss, 'stop_loss_hit_rate': sl_rate,  [cite: 281]
                    'take_profit_hit_rate': tp_rate, 'total_return': total_return, 'final_balance': balance [cite: 281]
                }
                return report, trades [cite: 282]
            else:
                return {'symbol': symbol, 'period': f"{days} days", 'total_trades': 0, 'message': 'No trades executed'}, [] [cite: 282]
                
        except Exception as e:
            logger.error(f"Error during backtesting {symbol}: {str(e)}", exc_info=True) [cite: 282]
            return {'symbol': symbol, 'error': str(e)}, [] [cite: 283]

    def _timeframe_to_minutes(self, timeframe):
        if not timeframe or not isinstance(timeframe, str) or len(timeframe) < 2: [cite: 283]
            return 15 # Default for safety 
        unit = timeframe[-1] [cite: 283]
        try:
            value = int(timeframe[:-1]) [cite: 283]
        except ValueError:
            return 15 # Default if timeframe number is invalid 

        if unit == 'm': return value [cite: 284]
        elif unit == 'h': return value * 60 [cite: 284]
        elif unit == 'd': return value * 60 * 24 [cite: 284]
        else: return 15 [cite: 284]

    def run_bot(self, interval=60, backtest_days=None):
        if backtest_days: [cite: 284]
            for symbol in self.symbols: [cite: 284]
                logger.info(f"Running backtest for {symbol} for {backtest_days} days...") [cite: 285]
                report, trades = self.backtest_strategy(symbol, days=backtest_days) [cite: 285]
                
                if 'error' not in report: [cite: 285]
                    def format_value(value, format_spec=":.2f"): [cite: 286]
                        if isinstance(value, (int, float)): [cite: 286]
                            try:
                                return f"{float(value):{format_spec}}" # Ensure it's float before formatting 
                            except (ValueError, TypeError):
                                return str(value) # Fallback if conversion fails 
                        return str(value) # Return 'N/A' or other string as is 

                    report_message = f"""🧪 *Backtest Results for {symbol}* 🧪
*Period:* {report.get('period', 'N/A')}
*Total Trades:* {report.get('total_trades', 'N/A')}
*Win Rate:* {format_value(report.get('win_rate', 'N/A'))}%
*Avg Profit per Trade:* {format_value(report.get('avg_profit', 'N/A'))}%
*Max Profit:* {format_value(report.get('max_profit', 'N/A'))}%
*Max Loss:* {format_value(report.get('max_loss', 'N/A'))}%
*Stop Loss Hit Rate:* {format_value(report.get('stop_loss_hit_rate', 'N/A'))}%
*Take Profit Hit Rate:* {format_value(report.get('take_profit_hit_rate', 'N/A'))}%
*Total Return:* {format_value(report.get('total_return', 'N/A'))}%
*Starting Balance:* $1000
*Final Balance:* ${format_value(report.get('final_balance', 'N/A'))}""" [cite: 288]
                    self.send_telegram_info(report_message) [cite: 289]
                    
                    if trades: [cite: 289]
                        recent_trades = trades[-5:] [cite: 289]
                        trades_message = f"*Recent Trades for {symbol} ({len(trades)} total):*\n" [cite: 290]
                        for trade in recent_trades: [cite: 290]
                            trades_message += (f"Entry: {trade['entry_time'].strftime('%Y-%m-%d %H:%M')} at ${format_value(trade.get('entry_price', 'N/A'), '.4f')}, " [cite: 290]
                                               f"Exit: {trade['exit_time'].strftime('%Y-%m-%d %H:%M')} at ${format_value(trade.get('exit_price', 'N/A'), '.4f')}, " [cite: 291]
                                               f"P/L: {format_value(trade.get('profit_pct', 'N/A'), '.2f')}%, Status: {trade.get('status', 'N/A')}\n") [cite: 291]
                        self.send_telegram_info(trades_message) [cite: 291]
                else:
                    self.send_telegram_info(f"❌ Backtest Failed for {symbol}: {report['error']}") [cite: 292]
        
        logger.info(f"Starting real-time monitoring of symbols: {', '.join(self.symbols)}") [cite: 292]
        self.send_telegram_info(f"▶️ *Real-time Monitoring Started*\nMonitoring symbols: {', '.join(self.symbols)} on {self.timeframes} timeframes using {self.default_ohlcv_timeframe} primary.") [cite: 292]
        
        min_rows_for_context = 30 [cite: 292]
        resend_signal_threshold_seconds = 30 * 60 [cite: 293]

        try:
            while True: [cite: 293]
                try:
                    for symbol in self.symbols: [cite: 293]
                        df_main_tf = self.fetch_ohlcv_data(symbol, timeframe=self.default_ohlcv_timeframe, limit=100) [cite: 293, 294]
                        if df_main_tf.empty or len(df_main_tf) < min_rows_for_context: [cite: 294]
                            logger.warning(f"Not enough {self.default_ohlcv_timeframe} data for {symbol} in run_bot ({len(df_main_tf)} candles). Skipping cycle for this symbol.") [cite: 294, 295]
                            continue
                        
                        df_with_indicators = self.calculate_indicators(df_main_tf) [cite: 295]
                        if df_with_indicators.empty: [cite: 296]
                            logger.warning(f"Not enough data after indicator calculation for {symbol} on {self.default_ohlcv_timeframe}. Skipping.") [cite: 296]
                            continue
                        
                        self.update_price_history(df_with_indicators, symbol) [cite: 297]
                        
                        latest_indicator_data = df_with_indicators.iloc[-1] [cite: 297]
                        current_price = latest_indicator_data['close'] [cite: 297]
                        current_time = datetime.now() [cite: 298]

                        for trade in list(self.active_trades[symbol]): [cite: 298]
                            trade_hit = False [cite: 298]
                            exit_reason = None [cite: 299]
                            profit_pct = 0.0 # Initialize as float 

                            trade_entry_price_float = float(trade['entry_price']) [cite: 300]
                            current_price_float = float(current_price) [cite: 300]
                            trade_stop_loss_float = float(trade['stop_loss']) [cite: 300]
                            trade_take_profit_float = float(trade['take_profit']) [cite: 301]

                            if (trade['signal_type'] == 1 and current_price_float <= trade_stop_loss_float) or \
                               (trade['signal_type'] == -1 and current_price_float >= trade_stop_loss_float): [cite: 301]
                                profit_pct = ((current_price_float - trade_entry_price_float) / trade_entry_price_float * 100) if trade['signal_type'] == 1 else ((trade_entry_price_float - current_price_float) / trade_entry_price_float * 100) [cite: 302]
                                msg_link = self.get_telegram_message_link(trade.get('signal_chat_id'), trade.get('signal_msg_id')) if trade.get('signal_msg_id') else "" [cite: 302]
                                link_text = f"\n[🔗 Original Signal]({msg_link})" if msg_link else "" [cite: 302, 303]
                                sl_message = f"⛔ *STOP LOSS HIT* ⛔\n*{symbol}* at {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n*Entry:* ${trade_entry_price_float:.4f} ({'BUY' if trade['signal_type'] == 1 else 'SELL'})\n*SL Price:* ${current_price_float:.4f} (Hit SL @ ${trade_stop_loss_float:.4f})\n*P/L:* {profit_pct:.2f}%{link_text}" [cite: 303]
                                self.send_telegram_info(sl_message) [cite: 303]
                                trade_hit = True [cite: 304]
                                exit_reason = 'stop_loss' [cite: 304]
                            
                            elif (trade['signal_type'] == 1 and current_price_float >= trade_take_profit_float) or \
                                 (trade['signal_type'] == -1 and current_price_float <= trade_take_profit_float): [cite: 305]
                                profit_pct = ((current_price_float - trade_entry_price_float) / trade_entry_price_float * 100) if trade['signal_type'] == 1 else ((trade_entry_price_float - current_price_float) / trade_entry_price_float * 100) [cite: 306]
                                msg_link = self.get_telegram_message_link(trade.get('signal_chat_id'), trade.get('signal_msg_id')) if trade.get('signal_msg_id') else "" [cite: 306]
                                link_text = f"\n[🔗 Original Signal]({msg_link})" if msg_link else "" [cite: 306]
                                tp_message = f"💰 *TAKE PROFIT HIT* 💰\n*{symbol}* at {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n*Entry:* ${trade_entry_price_float:.4f} ({'BUY' if trade['signal_type'] == 1 else 'SELL'})\n*TP Price:* ${current_price_float:.4f} (Hit TP @ ${trade_take_profit_float:.4f})\n*Profit:* {profit_pct:.2f}%{link_text}" [cite: 307]
                                self.send_telegram_info(tp_message) [cite: 307]
                                self.successful_signals[symbol] += 1 [cite: 308]
                                trade_hit = True [cite: 308]
                                exit_reason = 'take_profit' [cite: 308]

                            if trade_hit: [cite: 309]
                                trade_result = {
                                    'entry_time': trade['entry_time'].strftime("%Y-%m-%d %H:%M:%S"), 'entry_price': float(trade_entry_price_float), [cite: 309]
                                    'exit_time': current_time.strftime("%Y-%m-%d %H:%M:%S"), 'exit_price': float(current_price_float), [cite: 310]
                                    'profit_pct': float(profit_pct), 'exit_reason': exit_reason, [cite: 310]
                                    'signal_type': 'buy' if trade['signal_type'] == 1 else 'sell', [cite: 311]
                                    'duration_minutes': ((current_time - trade['entry_time']).total_seconds() / 60), [cite: 311]
                                    'predicted_time': trade.get('time_to_profit', 0) [cite: 311, 312]
                                }
                                self.price_history[symbol]['trade_results'].append(trade_result) [cite: 312]
                                self.active_trades[symbol].remove(trade) [cite: 312]
                                self.save_price_history(symbol)  [cite: 313]
                                continue 

                            expected_duration_minutes = trade.get('time_to_profit', 60)  [cite: 313]
                            if (current_time - trade['entry_time']).total_seconds() / 60 > expected_duration_minutes * 2 and not trade.get('time_alert_sent'): [cite: 314]
                                current_pnl = ((current_price_float - trade_entry_price_float) / trade_entry_price_float * 100 if trade['signal_type'] == 1 else (trade_entry_price_float - current_price_float) / trade_entry_price_float * 100) [cite: 314]
                                reminder_message = f"⏰ *TRADE TIME ALERT* ⏰\n*{symbol}* trade has exceeded 2x expected time.\n*Entry:* ${trade_entry_price_float:.4f} ({'BUY' if trade['signal_type'] == 1 else 'SELL'})\n*Current P/L:* {current_pnl:.2f}%\n*Expected Duration:* {expected_duration_minutes} mins." [cite: 315]
                                self.send_telegram_info(reminder_message) [cite: 315]
                                trade['time_alert_sent'] = True  [cite: 316]

                        trade_signal_details = self.generate_final_trade_signal(symbol) [cite: 316]

                        if trade_signal_details: [cite: 316]
                            signal_dir_str = trade_signal_details['direction'] [cite: 316]
                            current_signal_numeric = 1 if signal_dir_str == 'Long' else -1 [cite: 317]
                            time_since_last_signal = (current_time - self.last_signal_time[symbol]).total_seconds() if self.last_signal_time[symbol] else float('inf') [cite: 317]

                            if self.last_signal_direction[symbol] != current_signal_numeric or time_since_last_signal > resend_signal_threshold_seconds: [cite: 317]
                                market_context = self.get_market_context(df_with_indicators, symbol) [cite: 318]
                                
                                signal_message_text = (
                                    f"📈 {signal_dir_str} {symbol} 🚀\n\n" [cite: 319]
                                    f"Entry Price: {float(trade_signal_details['entry_price']):.4f}\n\n" [cite: 319]
                                    f"🎯 TP Targets:\n" [cite: 320]
                                    f"1️⃣ TP1: {float(trade_signal_details['TP1']):.4f}\n" [cite: 320]
                                    f"2️⃣ TP2: {float(trade_signal_details['TP2']):.4f}\n" [cite: 320]
                                    f"3️⃣ TP3: {float(trade_signal_details['TP3']):.4f}\n\n" [cite: 321]
                                    f"🛑 Stop Loss: {float(trade_signal_details['SL']):.4f}\n\n" [cite: 321]
                                    f"📊 Market Context ({self.default_ohlcv_timeframe}):\n" [cite: 321]
                                    f"   Price: ${float(market_context['price']):.4f}\n   24h Change: {float(market_context['price_change_24h']):.2f}%\n" [cite: 322]
                                    f"   Volatility (ATR%): {float(market_context['volatility']):.2f}%\n   RSI: {float(market_context['rsi']):.2f}\n" [cite: 322]
                                    f"   Trend (EMA): {market_context['trend']}\n   BB Position: {market_context['bollinger_position']}\n\n" [cite: 323]
                                    f"Confidence: 🔥🔥🔥 (multi-timeframe alignment)" [cite: 323]
                                )
                                if self.last_signal_time[symbol] is not None and self.last_signal_direction[symbol] != current_signal_numeric: [cite: 324]
                                    old_dir = 'Long' if self.last_signal_direction[symbol] == 1 else 'Short' [cite: 324]
                                    signal_message_text += f"\n\n⚠️ *Signal Direction Changed* from {old_dir} to {signal_dir_str}" [cite: 325]
                                
                                sent_telegram_obj = self.send_signal_message(signal_message_text) [cite: 326]
                                msg_id, chat_id = (sent_telegram_obj.message_id, sent_telegram_obj.chat.id) if sent_telegram_obj else (None, None) [cite: 326]

                                estimated_time_to_profit_active = 60 [cite: 326]
                                new_trade = {
                                    'entry_time': current_time, 'entry_price': float(trade_signal_details['entry_price']), [cite: 327]
                                    'signal_type': current_signal_numeric, 'stop_loss': float(trade_signal_details['SL']), [cite: 327]
                                    'take_profit': float(trade_signal_details['TP1']),  [cite: 328]
                                    'tp2': float(trade_signal_details['TP2']), 'tp3': float(trade_signal_details['TP3']), [cite: 328]
                                    'time_to_profit': estimated_time_to_profit_active, [cite: 329]
                                    'signal_msg_id': msg_id, 'signal_chat_id': chat_id, 'time_alert_sent': False [cite: 329]
                                }
                                self.active_trades[symbol].append(new_trade) [cite: 330]
                                self.last_signal_time[symbol] = current_time [cite: 330]
                                self.last_signal_direction[symbol] = current_signal_numeric [cite: 330]
                                self.signals_generated[symbol] += 1 [cite: 331]
                                logger.info(f"{symbol} - Signal: {signal_dir_str} sent. Entry: {float(trade_signal_details['entry_price']):.4f}, SL: {float(trade_signal_details['SL']):.4f}, TP1: {float(trade_signal_details['TP1']):.4f}") [cite: 331, 332]
                            else:
                                logger.info(f"{symbol} - Signal ({signal_dir_str}) for {symbol} is same as last or too recent. Not sending.") [cite: 332]
                        
                        if len(self.price_history[symbol]['trade_results']) % 10 == 0 and len(self.price_history[symbol]['trade_results']) > 0 :  [cite: 333]
                            if len(self.price_history[symbol]['trade_results']) > 200: [cite: 333]
                                self.price_history[symbol]['trade_results'] = self.price_history[symbol]['trade_results'][-200:] [cite: 334]
                            self.save_price_history(symbol) [cite: 334]
                
                    time.sleep(interval) [cite: 334]
                
                except ccxt.NetworkError as e: [cite: 335]
                    logger.error(f"Network error in monitoring loop: {str(e)}. Retrying after {interval}s.") [cite: 335]
                    self.send_telegram_info(f"⚠️ *Warning:* Network error: {str(e)}. Bot continues...") [cite: 335, 336]
                    time.sleep(interval) [cite: 336]
                except ccxt.ExchangeError as e: [cite: 336]
                    logger.error(f"Exchange error in monitoring loop: {str(e)}. Retrying after {interval}s.") [cite: 336]
                    self.send_telegram_info(f"⚠️ *Warning:* Exchange error: {str(e)}. Bot continues...") [cite: 336]
                    time.sleep(interval) [cite: 337]
                except Exception as e: [cite: 337]
                    logger.error(f"Error in monitoring loop: {str(e)}", exc_info=True) [cite: 337]
                    self.send_telegram_info(f"⚠️ *Warning:* General error in monitoring loop: {str(e)}. Bot continues...") [cite: 337]
                    time.sleep(interval * 2) [cite: 338]
                    
        except KeyboardInterrupt: [cite: 338]
            logger.info("Bot stopping due to KeyboardInterrupt...") [cite: 338]
            self.send_telegram_info("🛑 *Bot Stopped*\nThe trading bot was manually stopped.") [cite: 338]
        finally:
            logger.info("Saving all price histories before full exit...") [cite: 338, 339]
            for symbol_to_save in self.symbols: [cite: 339]
                if self.price_history.get(symbol_to_save):  [cite: 339]
                    self.save_price_history(symbol_to_save) [cite: 339]
            logger.info("All price histories saved. Bot shutdown complete.") [cite: 340]

if __name__ == "__main__":
    bot = KuCoinSwingBotEnhanced() # Changed class name
    bot.run_bot(interval=60, backtest_days=7) # Default interval and backtest days from backup.txt
